<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>This Game is the Coolest </title>
        <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body {
                background: #69a3ba;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 100vh;
                
                overflow: hidden;
            }
            canvas {
                border: 3px solid #000000;
                border-radius: 8px;
                image-rendering: pixelated;
                image-rendering: crisp-edges;
                background: #ffffff;
            }
            .score-bar {
                color: #000000;
                font-size: 14px;
                margin-top: 10px;
                letter-spacing: 1px;
            }
            h1 {
                color: #f9f9f9;
                font-size: 28px;
                margin-bottom: 8px;
                text-shadow: 2px 2px 0 #000000;
                letter-spacing: 3px;
            }
            .controls-hint {
                color: #000000;
                font-size: 13px;
                margin-bottom: 12px;
                letter-spacing: 1px;
            }
            .controls-hint span {
                color: #000000;
                background: #ffffff;
                padding: 2px 7px;
                border-radius: 4px;
                border: 1px solid #3a3a5e;
            }
        </style>
    </head>
    
    <body>
        <h1>Cat Jumpy Game</h1>
        <p class="controls-hint"><span>W/A/S/D</span> to move &nbsp; <span>Space</span> to jump</p>
        <canvas id="game" width="1000" height="460"></canvas>
        <p class="score-bar" id="scoreBar">Counter thingy here: 0</p>

        <script>
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const scoreBar = document.getElementById('scoreBar');

            const CANVAS_W = canvas.width;   // 1000
            const CANVAS_H = canvas.height;  // 460

            function spawnParticles() {}
            function updateParticles() {}

            // ── BACKGROUND IMAGE ──
            const bgImage = new Image();
            bgImage.src = 'Backg_no_grass.png';
            
            // ── GROUND/FLOOR IMAGE ──
            const groundImage = new Image();
            groundImage.src = 'Grass.png';  
            
            // ── PLATFORM IMAGE ──
            const boxImage = new Image();
            boxImage.src = 'platform_1.png';
            
            // ── ANIMATION FRAMES ──
            // Load as individual frames per state:
            
            const catIdleFrames = [
                loadImg('cat_sit.png'), 
                //loadImg('cat_loaf.png'),  
            ];
            const catRunFrames = [
                loadImg('cat_walk_1.png'), 
                loadImg('cat_stand.png'),  
                loadImg('cat_walk_2.png'),   
                loadImg('cat_stand.png'),  
            ];
            const catJumpFrames = [
                loadImg('cat_jump_1.png'),
                loadImg('cat_jump_2.png'),
                loadImg('cat_jump_3.png'),
                loadImg('cat_jump_4.png'),
                loadImg('cat_jump_5.png'),
                loadImg('cat_jump_6.png'),
            ];
            
            function loadImg(src) {
                const img = new Image();
                img.src = src;
                return img;
            }
            
            // ANIMATION SPEED
            const TICKS_PER_FRAME = 8;

            const SPRITE_W = 64;       // full PNG width
            const SPRITE_H = 64;       // full PNG height
            const HB_OFFSET_X = 12;    // px from left edge of sprite to hitbox start
            const HB_OFFSET_Y = 24;    // px from top edge of sprite to hitbox start
            const HB_W = 40;           // hitbox width  (actual cat body)
            const HB_H = 30;           // hitbox height (actual cat body)


            // Platforms
            const platforms = [];
            const PLAT_MIN_W = 60;
            const PLAT_MAX_W = 120;
            const PLAT_H = 24;
            const PLAT_VERTICAL_GAP_MIN = 70;
            const PLAT_VERTICAL_GAP_MAX = 120;
            const PLAT_MARGIN = 40;

            // ── FIX: GROUND_Y moved here (was below cat). ──
            // const declarations can't be used before they're declared,
            // and cat's initializer uses GROUND_Y, so it must come first.
            const GROUND_Y = 430;

            // Cat / Player
            const cat = {
                x: 480, y: GROUND_Y - HB_H,
                vx: 0, vy: 0,
                w: HB_W, h: HB_H, //adjust?
                onGround: false,
                facing: 1, // 1 = right, -1 = left
                state: 'idle', // idle, run, jump
                frame: 0,
            };

            // Physics constants
            const GRAVITY = 0.45;
            const JUMP_FORCE = -9.5;
            const MOVE_SPEED = 2.5;
            const FRICTION = 0.82;
            // ── FIX: GROUND_Y was here — moved above cat object ──
            // const GROUND_Y = 430;


            // Platform generation
            let highestPlatformY = GROUND_Y;

            function generatePlatformsUpTo(targetY) {
                while (highestPlatformY > targetY) {
                    const gap = PLAT_VERTICAL_GAP_MIN + Math.random() * (PLAT_VERTICAL_GAP_MAX - PLAT_VERTICAL_GAP_MIN);
                    highestPlatformY -= gap;
                    const pw = PLAT_MIN_W + Math.random() * (PLAT_MAX_W - PLAT_MIN_W);
                    const px = PLAT_MARGIN + Math.random() * (CANVAS_W - pw - PLAT_MARGIN * 2);
                    platforms.push({
                        x: px, y: highestPlatformY,
                        w: pw, h: PLAT_H, touched: false,
                    });
                }
            }

            // First platform always reachable from ground
            platforms.push({
                x: cat.x - 20, y: GROUND_Y - 90,
                w: 90, h: PLAT_H, touched: false,
            });
            highestPlatformY = GROUND_Y - 90;
            generatePlatformsUpTo(highestPlatformY - CANVAS_H * 2);

            // Remove platforms that scrolled far below camera
            function pruneOldPlatforms() {
                const cutoff = camera.y + CANVAS_H + 200;
                for (let i = platforms.length - 1; i >= 0; i--) {
                    if (platforms[i].y > cutoff) platforms.splice(i, 1);
                }
            }

            // Input
            const keys = {};
            window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if(e.key === ' ') e.preventDefault();
            });
            window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            });

            // Camera 
            const camera = { y: GROUND_Y - CANVAS_H + 60 };

            // Score 
            let score = 0;

            // Game loop
            let globalFrame = 0;

            function update() {
            // Input
            let moving = false;
            if(keys['a'] || keys['arrowleft']) { cat.vx -= MOVE_SPEED * 0.3; cat.facing = -1; moving = true; }
            if(keys['d'] || keys['arrowright']) { cat.vx += MOVE_SPEED * 0.3; cat.facing = 1; moving = true; }
            if((keys['w'] || keys['arrowup'] || keys[' ']) && cat.onGround) {
                cat.vy = JUMP_FORCE;
                cat.onGround = false;
                spawnParticles(cat.x + cat.w/2, cat.y + cat.h, 6, '#fce4b8');
            }
            // Soft down (crouch feel)
            if(keys['s'] || keys['arrowdown']) {
                if(!cat.onGround) cat.vy += 0.5;
            }

            // Physics
            cat.vx *= FRICTION;
            cat.vy += GRAVITY;
            cat.x += cat.vx;
            cat.y += cat.vy;

            // Clamp speed
            if(Math.abs(cat.vx) < 0.1) cat.vx = 0;

            if (cat.x < 0) { cat.x = 0; cat.vx = 0; }
            if (cat.x + cat.w > CANVAS_W) { cat.x = CANVAS_W - cat.w; cat.vx = 0; }

            // Ground collision
            cat.onGround = false;
            if(cat.y + cat.h >= GROUND_Y) {
                cat.y = GROUND_Y - cat.h;
                cat.vy = 0;
                cat.onGround = true;
            }

            // Platform collision
            platforms.forEach(plat => {
                const prevBottom = cat.y + cat.h - cat.vy;
                if(
                cat.x + cat.w > plat.x &&
                cat.x < plat.x + plat.w &&
                cat.y + cat.h >= plat.y &&
                cat.y + cat.h <= plat.y + plat.h + 4 &&
                cat.vy >= 0 &&
                prevBottom <= plat.y + 2
                ) {
                cat.y = plat.y - cat.h;
                cat.vy = 0;
                cat.onGround = true;
                if(!plat.touched) {
                    plat.touched = true;
                    score++;
                    scoreBar.textContent = `Counter thingy here: ${score}`;
                    spawnParticles(cat.x + cat.w/2, cat.y + cat.h, 10, '#ffb7c5');
                    if(score === platforms.length) {
                    }
                }
                }
            });

            // State
            if(!cat.onGround) {
                cat.state = 'jump';
            } else if(Math.abs(cat.vx) > 0.5 || moving) {
                cat.state = 'run';
            } else {
                cat.state = 'idle';
            }

            cat.frame++;

            // Camera
            const targetCY = cat.y - CANVAS_H * 0.35;
            camera.y += (targetCY - camera.y) * 0.08;

            // ── NEW: Generate platforms above as camera rises ──
            generatePlatformsUpTo(camera.y - CANVAS_H);

            // ── NEW: Prune platforms far below ──
            pruneOldPlatforms();

            updateParticles();
            }

            function draw() {
            ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
            //backhround
            if (bgImage.complete && bgImage.naturalWidth > 0) {
                const bgW = CANVAS_W;
                const bgH = CANVAS_H;
                const parallaxY = -(camera.y * 0.2);
                const offsetY = ((parallaxY % bgH) + bgH) % bgH;
                ctx.drawImage(bgImage, 0, offsetY - bgH, bgW, bgH);
                ctx.drawImage(bgImage, 0, offsetY, bgW, bgH);
                ctx.drawImage(bgImage, 0, offsetY + bgH, bgW, bgH);
            } else {
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
            }

            //ground
            const groundScreenY = GROUND_Y - camera.y;
            if (groundScreenY < CANVAS_H + 60) {
                if (groundImage.complete && groundImage.naturalWidth > 0) {
                    const gw = groundImage.naturalWidth || 64;
                    const gh = 60;
                    for (let x = 0; x < CANVAS_W; x += gw) {
                        ctx.drawImage(groundImage, x, groundScreenY, gw, gh);
                    }
                } else {
                    ctx.fillStyle = '#3a7a32';
                    ctx.fillRect(0, groundScreenY, CANVAS_W, 60);
                }
            }

            //platforms
            platforms.forEach(plat => {
                const screenX = plat.x;
                const screenY = plat.y - camera.y;
                if (screenY > -plat.h && screenY < CANVAS_H) {
                    if (boxImage.complete && boxImage.naturalWidth > 0) {
                        ctx.drawImage(boxImage, screenX, screenY, plat.w, plat.h);
                    } else {
                        ctx.fillStyle = '#c49a6c';
                        ctx.fillRect(screenX, screenY, plat.w, plat.h);
                        ctx.strokeStyle = '#8b6914';
                        ctx.strokeRect(screenX, screenY, plat.w, plat.h);
                    }
                }
            });


            // Pick the right animation array based on cat.state
            let frames;
            if(cat.state === 'jump') frames = catJumpFrames;
            else if(cat.state === 'run') frames = catRunFrames;
            else frames = catIdleFrames;
            
            // Cycle through frames
            const frameIndex = Math.floor(cat.frame / TICKS_PER_FRAME) % frames.length;
            const img = frames[frameIndex];
            
            const spriteScreenX = cat.x - HB_OFFSET_X;
            const spriteScreenY = (cat.y - HB_OFFSET_Y) - camera.y;
            
            //cat drawing
            ctx.save();
            if(cat.facing === -1) {
               // Flip horizontally when facing left
               ctx.translate(spriteScreenX + SPRITE_W, spriteScreenY);
               ctx.scale(-1, 1);
               ctx.drawImage(img, 0, 0, SPRITE_W, SPRITE_H);
            } else {
               ctx.drawImage(img, spriteScreenX, spriteScreenY, SPRITE_W, SPRITE_H);
            }
            ctx.restore();
  
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 1;
            ctx.strokeRect(cat.x, cat.y - camera.y, cat.w, cat.h);

            globalFrame++;
            }
           
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
            
            gameLoop();
        </script>
    </body>

</html>
