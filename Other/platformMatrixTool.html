<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Platform Level Editor</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        background: #2a2a2a;
        color: #eee;
        font-family: 'Courier New', monospace;
        display: flex;
        height: 100vh;
        overflow: hidden;
    }

    /* Left side: canvas */
    #editor-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
        overflow: hidden;
    }
    #editor-panel h2 {
        margin-bottom: 6px;
        font-size: 16px;
        color: #aaa;
    }
    #instructions {
        font-size: 11px;
        color: #888;
        margin-bottom: 8px;
        text-align: center;
        line-height: 1.5;
    }
    canvas {
        border: 2px solid #555;
        cursor: crosshair;
        background: #87CEEB;
    }

    /* Right side: output */
    #output-panel {
        width: 380px;
        background: #1e1e1e;
        border-left: 2px solid #444;
        display: flex;
        flex-direction: column;
        padding: 10px;
    }
    #output-panel h3 {
        font-size: 14px;
        color: #aaa;
        margin-bottom: 8px;
    }
    .btn-row {
        display: flex;
        gap: 6px;
        margin-bottom: 8px;
        flex-wrap: wrap;
    }
    button {
        background: #444;
        color: #eee;
        border: 1px solid #666;
        padding: 5px 10px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        cursor: pointer;
        border-radius: 3px;
    }
    button:hover { background: #555; }
    button.active { background: #668; border-color: #88a; }
    button.danger { background: #644; }
    button.danger:hover { background: #855; }

    #level-tabs {
        display: flex;
        gap: 4px;
        margin-bottom: 8px;
    }
    #level-tabs button.active { background: #586; }

    textarea {
        flex: 1;
        background: #111;
        color: #8f8;
        border: 1px solid #444;
        font-family: 'Courier New', monospace;
        font-size: 11px;
        padding: 8px;
        resize: none;
        border-radius: 3px;
    }
    #status {
        font-size: 11px;
        color: #888;
        margin-top: 6px;
        min-height: 16px;
    }
    #scroll-info {
        font-size: 11px;
        color: #666;
        margin-top: 4px;
    }
</style>
</head>
<body>

<div id="editor-panel">
    <h2>Platform Level Editor</h2>
    <div id="instructions">
        <b>Drag</b> platforms to move them &nbsp;|&nbsp;
        <b>Double-click</b> empty space to add &nbsp;|&nbsp;
        <b>Right-click</b> a platform to delete<br>
        <b>Scroll wheel</b> to pan up/down &nbsp;|&nbsp;
        <b>T</b> key while hovering to toggle type &nbsp;|&nbsp;
        <b>R</b> key to resize (cycles widths)
    </div>
    <canvas id="canvas" width="1000" height="460"></canvas>
    <div id="scroll-info">World Y: <span id="cam-y">0</span> | Scroll to pan</div>
</div>

<div id="output-panel">
    <h3>Level Data</h3>
    <div id="level-tabs"></div>
    <div class="btn-row">
        <button onclick="copyOutput()">ðŸ“‹ Copy Array</button>
        <button onclick="copyAllLevels()">ðŸ“‹ Copy All Levels</button>
        <button class="danger" onclick="clearCurrentLevel()">ðŸ—‘ Clear Level</button>
    </div>
    <div class="btn-row">
        <button onclick="addLevel()">+ Add Level</button>
        <button class="danger" onclick="removeLevel()">- Remove Level</button>
    </div>
    <textarea id="output" readonly></textarea>
    <div id="status"></div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const output = document.getElementById('output');
const status = document.getElementById('status');
const camYDisplay = document.getElementById('cam-y');

const CANVAS_W = 1000;
const CANVAS_H = 460;
const GROUND_Y = 430;

// â”€â”€ Level data â”€â”€
// Each level has boundaries and a list of platforms
let levels = [
    {
        name: 'Level 1',
        yBottom: GROUND_Y,
        yTop: -500,
        platforms: [
            { x: 460, y: 340, w: 100, type: 'box' },
            { x: 250, y: 260, w: 90,  type: 'box' },
            { x: 600, y: 190, w: 110, type: 'box' },
            { x: 350, y: 110, w: 85,  type: 'box' },
            { x: 150, y: 30,  w: 100, type: 'box' },
            { x: 700, y: -40, w: 90,  type: 'box' },
            { x: 450, y: -120, w: 95, type: 'box' },
            { x: 200, y: -200, w: 100, type: 'box' },
            { x: 550, y: -290, w: 85, type: 'box' },
            { x: 350, y: -380, w: 110, type: 'box' },
            { x: 700, y: -460, w: 90, type: 'box' },
        ],
    },
    {
        name: 'Level 2',
        yBottom: -500,
        yTop: -1500,
        platforms: [
            { x: 500, y: -550,  w: 100, type: 'box' },
            { x: 300, y: -650,  w: 110, type: 'newobject' },
            { x: 650, y: -740,  w: 90,  type: 'box' },
            { x: 200, y: -830,  w: 100, type: 'newobject' },
            { x: 500, y: -920,  w: 85,  type: 'box' },
            { x: 750, y: -1010, w: 100, type: 'newobject' },
            { x: 400, y: -1100, w: 110, type: 'box' },
            { x: 150, y: -1190, w: 90,  type: 'newobject' },
            { x: 600, y: -1280, w: 100, type: 'box' },
            { x: 350, y: -1370, w: 95,  type: 'newobject' },
            { x: 550, y: -1460, w: 100, type: 'box' },
        ],
    },
    {
        name: 'Level 3',
        yBottom: -1500,
        yTop: -2500,
        platforms: [
            { x: 400, y: -1560, w: 100, type: 'newobject' },
            { x: 200, y: -1660, w: 90,  type: 'box' },
            { x: 650, y: -1750, w: 110, type: 'newobject' },
            { x: 350, y: -1840, w: 85,  type: 'box' },
            { x: 550, y: -1930, w: 100, type: 'newobject' },
            { x: 150, y: -2020, w: 95,  type: 'box' },
            { x: 700, y: -2110, w: 90,  type: 'newobject' },
            { x: 400, y: -2200, w: 110, type: 'box' },
            { x: 250, y: -2300, w: 100, type: 'newobject' },
            { x: 500, y: -2400, w: 100, type: 'box' },
        ],
    },
];

let currentLevelIdx = 0;
let cameraY = GROUND_Y - CANVAS_H + 60;  // start showing ground

// Visual height for drawing platforms in the editor
const PLAT_DRAW_H = 20;
const WIDTH_OPTIONS = [80, 90, 100, 110, 120, 150];

// Colors per type
const TYPE_COLORS = {
    box:       { fill: '#c49a6c', stroke: '#8b6914', label: 'BOX' },
    newobject: { fill: '#7caabb', stroke: '#4a7a8b', label: 'NEW' },
};

// â”€â”€ Drag state â”€â”€
let dragging = null;    // { levelIdx, platIdx, offsetX, offsetY }
let hoveredPlat = null; // { levelIdx, platIdx }

// â”€â”€ Helper: get all platforms across all levels for rendering â”€â”€
function allPlatforms() {
    const result = [];
    levels.forEach((lvl, li) => {
        lvl.platforms.forEach((p, pi) => {
            result.push({ ...p, levelIdx: li, platIdx: pi });
        });
    });
    return result;
}

// â”€â”€ Helper: find platform at screen position â”€â”€
function platAtScreen(sx, sy) {
    const worldY = sy + cameraY;
    // Check in reverse so topmost drawn (last) is picked first
    for (let li = levels.length - 1; li >= 0; li--) {
        const plats = levels[li].platforms;
        for (let pi = plats.length - 1; pi >= 0; pi--) {
            const p = plats[pi];
            if (sx >= p.x && sx <= p.x + p.w &&
                worldY >= p.y && worldY <= p.y + PLAT_DRAW_H) {
                return { levelIdx: li, platIdx: pi };
            }
        }
    }
    return null;
}

// â”€â”€ Drawing â”€â”€
function draw() {
    ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

    // Sky gradient
    const grd = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    grd.addColorStop(0, '#5a9cbf');
    grd.addColorStop(1, '#87CEEB');
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // Level boundary lines
    levels.forEach((lvl, i) => {
        const topScreenY = lvl.yTop - cameraY;
        const botScreenY = lvl.yBottom - cameraY;

        // Level zone shading (alternating slight tint)
        if (i % 2 === 1) {
            const t = Math.max(0, topScreenY);
            const b = Math.min(CANVAS_H, botScreenY);
            if (b > t) {
                ctx.fillStyle = 'rgba(0,0,0,0.05)';
                ctx.fillRect(0, t, CANVAS_W, b - t);
            }
        }

        // Top boundary line
        if (topScreenY > -10 && topScreenY < CANVAS_H + 10) {
            ctx.strokeStyle = '#ff6666';
            ctx.lineWidth = 1;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(0, topScreenY);
            ctx.lineTo(CANVAS_W, topScreenY);
            ctx.stroke();
            ctx.setLineDash([]);
            // Label
            ctx.fillStyle = '#ff6666';
            ctx.font = '12px Courier New';
            ctx.fillText(`â”€â”€ ${lvl.name} top (y: ${lvl.yTop}) â”€â”€`, 10, topScreenY - 4);
        }

        // Bottom boundary line
        if (botScreenY > -10 && botScreenY < CANVAS_H + 10) {
            ctx.strokeStyle = '#66aa66';
            ctx.lineWidth = 1;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(0, botScreenY);
            ctx.lineTo(CANVAS_W, botScreenY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#66aa66';
            ctx.font = '12px Courier New';
            ctx.fillText(`â”€â”€ ${lvl.name} bottom (y: ${lvl.yBottom}) â”€â”€`, 10, botScreenY + 14);
        }
    });

    // Ground
    const groundScreenY = GROUND_Y - cameraY;
    if (groundScreenY < CANVAS_H + 10) {
        ctx.fillStyle = '#3a7a32';
        ctx.fillRect(0, groundScreenY, CANVAS_W, 100);
        ctx.fillStyle = '#4a9a42';
        ctx.fillRect(0, groundScreenY, CANVAS_W, 4);
    }

    // Cat start position indicator
    const catScreenY = (GROUND_Y - 44) - cameraY;
    ctx.fillStyle = 'rgba(255,165,0,0.4)';
    ctx.fillRect(480 - 10, catScreenY, 44, 44);
    ctx.strokeStyle = 'orange';
    ctx.lineWidth = 1;
    ctx.strokeRect(480 - 10, catScreenY, 44, 44);
    ctx.fillStyle = 'orange';
    ctx.font = '10px Courier New';
    ctx.fillText('CAT START', 480 - 10, catScreenY - 3);

    // Platforms
    levels.forEach((lvl, li) => {
        lvl.platforms.forEach((p, pi) => {
            const screenX = p.x;
            const screenY = p.y - cameraY;

            if (screenY > -PLAT_DRAW_H - 10 && screenY < CANVAS_H + 10) {
                const tc = TYPE_COLORS[p.type] || TYPE_COLORS.box;
                const isHovered = hoveredPlat && hoveredPlat.levelIdx === li && hoveredPlat.platIdx === pi;
                const isDragging = dragging && dragging.levelIdx === li && dragging.platIdx === pi;
                const isCurrentLevel = (li === currentLevelIdx);

                // Platform body
                ctx.fillStyle = tc.fill;
                ctx.fillRect(screenX, screenY, p.w, PLAT_DRAW_H);
                ctx.strokeStyle = isDragging ? '#fff' : isHovered ? '#ffff00' : tc.stroke;
                ctx.lineWidth = isDragging ? 2 : isHovered ? 2 : 1;
                ctx.strokeRect(screenX, screenY, p.w, PLAT_DRAW_H);

                // Dim if not current level
                if (!isCurrentLevel) {
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(screenX, screenY, p.w, PLAT_DRAW_H);
                }

                // Type label + coordinates
                ctx.fillStyle = '#fff';
                ctx.font = '10px Courier New';
                ctx.fillText(tc.label, screenX + 3, screenY + 13);
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.font = '9px Courier New';
                ctx.fillText(`${Math.round(p.x)},${Math.round(p.y)} w:${p.w}`, screenX + 3, screenY + PLAT_DRAW_H + 10);
            }
        });
    });

    camYDisplay.textContent = Math.round(cameraY);
}

// â”€â”€ Mouse events â”€â”€
canvas.addEventListener('mousedown', e => {
    if (e.button !== 0) return; // left click only
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    const hit = platAtScreen(sx, sy);
    if (hit) {
        const p = levels[hit.levelIdx].platforms[hit.platIdx];
        dragging = {
            levelIdx: hit.levelIdx,
            platIdx: hit.platIdx,
            offsetX: sx - p.x,
            offsetY: sy - (p.y - cameraY),
        };
        currentLevelIdx = hit.levelIdx;
        renderTabs();
    }
});

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    if (dragging) {
        const p = levels[dragging.levelIdx].platforms[dragging.platIdx];
        p.x = Math.round(Math.max(0, Math.min(CANVAS_W - p.w, sx - dragging.offsetX)));
        p.y = Math.round(sy - dragging.offsetY + cameraY);
        updateOutput();
        draw();
    } else {
        const hit = platAtScreen(sx, sy);
        hoveredPlat = hit;
        draw();
    }
});

canvas.addEventListener('mouseup', () => {
    dragging = null;
    updateOutput();
    draw();
});

canvas.addEventListener('mouseleave', () => {
    dragging = null;
    hoveredPlat = null;
    draw();
});

// Double-click to add platform
canvas.addEventListener('dblclick', e => {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const worldY = Math.round(sy + cameraY);

    // Don't add if clicking on existing platform
    if (platAtScreen(sx, sy)) return;

    levels[currentLevelIdx].platforms.push({
        x: Math.round(Math.max(0, sx - 50)),
        y: worldY,
        w: 100,
        type: 'box',
    });
    updateOutput();
    draw();
    setStatus('Added new platform');
});

// Right-click to delete
canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    const hit = platAtScreen(sx, sy);
    if (hit) {
        levels[hit.levelIdx].platforms.splice(hit.platIdx, 1);
        updateOutput();
        draw();
        setStatus('Deleted platform');
    }
});

// Scroll to pan
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    cameraY += e.deltaY * 0.8;
    draw();
}, { passive: false });

// Keyboard: T to toggle type, R to resize
window.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 't' && hoveredPlat) {
        const p = levels[hoveredPlat.levelIdx].platforms[hoveredPlat.platIdx];
        const types = Object.keys(TYPE_COLORS);
        const idx = types.indexOf(p.type);
        p.type = types[(idx + 1) % types.length];
        updateOutput();
        draw();
        setStatus(`Toggled to: ${p.type}`);
    }
    if (e.key.toLowerCase() === 'r' && hoveredPlat) {
        const p = levels[hoveredPlat.levelIdx].platforms[hoveredPlat.platIdx];
        const idx = WIDTH_OPTIONS.indexOf(p.w);
        p.w = WIDTH_OPTIONS[(idx + 1) % WIDTH_OPTIONS.length];
        updateOutput();
        draw();
        setStatus(`Width: ${p.w}`);
    }
});

// â”€â”€ Output â”€â”€
function updateOutput() {
    const lvl = levels[currentLevelIdx];
    let text = `// ${lvl.name}\n`;
    text += `// yBottom: ${lvl.yBottom}, yTop: ${lvl.yTop}\n`;
    text += `platforms: [\n`;
    lvl.platforms.forEach(p => {
        text += `    { x: ${Math.round(p.x)}, y: ${Math.round(p.y)}, w: ${p.w}, type: '${p.type}' },\n`;
    });
    text += `],`;
    output.value = text;
}

function copyOutput() {
    navigator.clipboard.writeText(output.value).then(() => {
        setStatus('Copied current level to clipboard!');
    });
}

function copyAllLevels() {
    let text = '';
    levels.forEach(lvl => {
        text += `// ${lvl.name}  (yBottom: ${lvl.yBottom}, yTop: ${lvl.yTop})\n`;
        text += `platforms: [\n`;
        lvl.platforms.forEach(p => {
            text += `    { x: ${Math.round(p.x)}, y: ${Math.round(p.y)}, w: ${p.w}, type: '${p.type}' },\n`;
        });
        text += `],\n\n`;
    });
    navigator.clipboard.writeText(text).then(() => {
        setStatus('Copied ALL levels to clipboard!');
    });
}

function clearCurrentLevel() {
    if (confirm(`Clear all platforms in ${levels[currentLevelIdx].name}?`)) {
        levels[currentLevelIdx].platforms = [];
        updateOutput();
        draw();
        setStatus('Level cleared');
    }
}

function addLevel() {
    const lastLvl = levels[levels.length - 1];
    const newTop = lastLvl.yTop - 1000;
    levels.push({
        name: `Level ${levels.length + 1}`,
        yBottom: lastLvl.yTop,
        yTop: newTop,
        platforms: [],
    });
    currentLevelIdx = levels.length - 1;
    renderTabs();
    updateOutput();
    // Scroll to new level
    cameraY = levels[currentLevelIdx].yBottom - CANVAS_H + 60;
    draw();
    setStatus(`Added ${levels[currentLevelIdx].name}`);
}

function removeLevel() {
    if (levels.length <= 1) { setStatus('Cannot remove last level'); return; }
    if (confirm(`Remove ${levels[currentLevelIdx].name}?`)) {
        levels.splice(currentLevelIdx, 1);
        currentLevelIdx = Math.min(currentLevelIdx, levels.length - 1);
        renderTabs();
        updateOutput();
        draw();
        setStatus('Level removed');
    }
}

function setStatus(msg) {
    status.textContent = msg;
    clearTimeout(setStatus._timer);
    setStatus._timer = setTimeout(() => { status.textContent = ''; }, 3000);
}

// â”€â”€ Level tabs â”€â”€
function renderTabs() {
    const container = document.getElementById('level-tabs');
    container.innerHTML = '';
    levels.forEach((lvl, i) => {
        const btn = document.createElement('button');
        btn.textContent = lvl.name;
        btn.className = (i === currentLevelIdx) ? 'active' : '';
        btn.onclick = () => {
            currentLevelIdx = i;
            renderTabs();
            updateOutput();
            // Scroll to this level
            cameraY = levels[i].yBottom - CANVAS_H + 60;
            draw();
        };
        container.appendChild(btn);
    });
}

// â”€â”€ Init â”€â”€
renderTabs();
updateOutput();
draw();
</script>
</body>
</html>
