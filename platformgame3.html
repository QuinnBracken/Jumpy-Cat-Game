<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Coolest Thing Ever</title>
        <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body {
                background: #69a3ba;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 100vh;
                
                overflow: hidden;
            }
            canvas {
                border: 3px solid #000000;
                border-radius: 8px;
                image-rendering: pixelated;
                image-rendering: crisp-edges;
                background: #ffffff;
            }
            .score-bar {
                color: #000000;
                font-size: 14px;
                margin-top: 10px;
                letter-spacing: 1px;
            }
            h1 {
                color: #f9f9f9;
                font-size: 28px;
                margin-bottom: 8px;
                text-shadow: 2px 2px 0 #000000;
                letter-spacing: 3px;
            }
            .controls-hint {
                color: #000000;
                font-size: 13px;
                margin-bottom: 12px;
                letter-spacing: 1px;
            }
            .controls-hint span {
                color: #000000;
                background: #ffffff;
                padding: 2px 7px;
                border-radius: 4px;
                border: 1px solid #3a3a5e;
            }
        </style>
    </head>
    
    <body>
        <h1>Jumpy Cat</h1>
        <p class="controls-hint"><span>W/A/S/D</span> to move &nbsp; <span>Space</span> to jump</p>
        <canvas id="game" width="1000" height="460"></canvas>
        <p class="score-bar" id="scoreBar">Boxes jumped on: 0</p>

        <script>
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const scoreBar = document.getElementById('scoreBar');

            const CANVAS_W = canvas.width;   // 1000
            const CANVAS_H = canvas.height;  // 460

            function spawnParticles() {}
            function updateParticles() {}

            // ── BACKGROUND IMAGE ──
            const bgImage1 = new Image();
            bgImage1.src = 'Background_Test_1.png';
            const bgImage2 = new Image();
            bgImage2.src = 'Sky_2.png';  
            const bgImage3 = new Image();
            bgImage3.src = 'Sky_3.png';  
            
            // ── GROUND/FLOOR IMAGE ──
            const groundImage = new Image();
            groundImage.src = 'Grass.png';  
            
            // ── PLATFORM IMAGE ──
            const boxImage = new Image();
            boxImage.src = 'platform_1.png';
            
            // ── ANIMATION FRAMES ──
            // Load as individual frames per state:
            
            const catIdleFrames = [
                loadImg('cat_sit.png'), 
                //loadImg('cat_loaf.png'),  
            ];
            const catRunFrames = [
                loadImg('cat_walk_1.png'), 
                loadImg('cat_stand.png'),  
                loadImg('cat_walk_2.png'),   
                loadImg('cat_stand.png'),  
            ];
            const catJumpFrames = [
                loadImg('cat_jump_1.png'),
                loadImg('cat_jump_2.png'),
                loadImg('cat_jump_3.png'),
                loadImg('cat_jump_4.png'),
                loadImg('cat_jump_5.png'),
                loadImg('cat_jump_6.png'),
            ];
            
            function loadImg(src) {
                const img = new Image();
                img.src = src;
                return img;
            }
            
            // ANIMATION SPEED
            const TICKS_PER_FRAME = 8;

            // ── FIX: Hitbox values recalculated from actual sprite pixel data ──
            // Cat sprites are 64x64 PNGs. Measured bounding boxes of visible pixels:
            //   cat_stand:  (10,6)  to (57,50) → 47×44
            //   cat_walk_1: (8,8)   to (55,52) → 47×44
            //   cat_walk_2: (10,6)  to (57,50) → 47×44
            //   cat_sit:    (11,14) to (55,50) → 44×36
            //   cat_jump_*: varies, ~(3-8, 7-12) to (56-63, 50-56)
            // The cat's FEET consistently land at about y=50 in the sprite.
            // The hitbox bottom must align with the feet.
            const SPRITE_W = 64;
            const SPRITE_H = 64;
            const HB_W = 44;           // ── FIX: was 40. ~average visible width ──
            const HB_H = 44;           // ── FIX: was 30. ~average visible height ──
            const HB_OFFSET_X = 10;    // ── FIX: was 12. content starts ~x:10 ──
            const HB_OFFSET_Y = 6;     // ── FIX: was 24. content starts ~y:6 ──
            // Check: hitbox bottom in sprite = HB_OFFSET_Y + HB_H = 6 + 44 = 50 ✓ (matches feet)


            // Platforms
            const platforms = [];
            const PLAT_MIN_W = 80;     // ── FIX: was 60, wider for playability ──
            const PLAT_MAX_W = 150;    // ── FIX: was 120 ──
            // ── FIX: platform_1.png is 120×120 but the visible box is only 83×52.
            // Old code used PLAT_H=24 for both drawing AND collision, squishing the image.
            // Now we separate collision height from visual height. ──
            const PLAT_HIT_H = 30;     // ── FIX: was PLAT_H=24. Thin collision zone (top of box) ──
            const PLAT_VERTICAL_GAP_MIN = 35;   // ── FIX: was 70. adjusted for taller cat hitbox ──
            const PLAT_VERTICAL_GAP_MAX = 70;   // ── FIX: was 120 ──
            const PLAT_MARGIN = 40;

            const GROUND_Y = 430;

            // Cat / Player
            const cat = {
                x: 480, y: GROUND_Y - HB_H,
                vx: 0, vy: 0,
                w: HB_W, h: HB_H,
                onGround: false,
                facing: 1, // 1 = right, -1 = left
                state: 'idle', // idle, run, jump
                frame: 0,
            };

            // Physics constants
            const GRAVITY = 0.8;
            const JUMP_FORCE = -16;
            const MOVE_SPEED = 5;
            const FRICTION = 0.73;


            // Platform generation
            let highestPlatformY = GROUND_Y;

            function generatePlatformsUpTo(targetY) {
                while (highestPlatformY > targetY) {
                    const gap = PLAT_VERTICAL_GAP_MIN + Math.random() * (PLAT_VERTICAL_GAP_MAX - PLAT_VERTICAL_GAP_MIN);
                    highestPlatformY -= gap-5;
                    const pw = PLAT_MIN_W + Math.random() * (PLAT_MAX_W - PLAT_MIN_W);
                    const px = PLAT_MARGIN + Math.random() * (CANVAS_W - pw - PLAT_MARGIN * 2);
                    platforms.push({
                        x: px, y: highestPlatformY,
                        w: pw, h: PLAT_HIT_H, touched: false,
                        // ── FIX: h is now collision height only. Visual drawn separately. ──
                    });
                }
            }

            // First platform always reachable from ground
            platforms.push({
                x: cat.x - 20, y: GROUND_Y - 100,
                w: 100, h: PLAT_HIT_H, touched: false,
            });
            highestPlatformY = GROUND_Y - 100;
            generatePlatformsUpTo(highestPlatformY - CANVAS_H * 2);

            // Remove platforms that scrolled far below camera
            function pruneOldPlatforms() {
                const cutoff = camera.y + CANVAS_H + 200;
                for (let i = platforms.length - 1; i >= 0; i--) {
                    if (platforms[i].y > cutoff) platforms.splice(i, 1);
                }
            }

            // Input
            const keys = {};
            window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if(e.key === ' ') e.preventDefault();
            });
            window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            });

            // Camera 
            const camera = { y: GROUND_Y - CANVAS_H + 60 };

            // Score 
            let score = 0;

            // Game loop
            let globalFrame = 0;

            function update() {
            // Input
            let moving = false;
            if(keys['a'] || keys['arrowleft']) { cat.vx -= MOVE_SPEED * 0.3; cat.facing = -1; moving = true; }
            if(keys['d'] || keys['arrowright']) { cat.vx += MOVE_SPEED * 0.3; cat.facing = 1; moving = true; }
            if((keys['w'] || keys['arrowup'] || keys[' ']) && cat.onGround) {
                cat.vy = JUMP_FORCE;
                cat.onGround = false;
                spawnParticles(cat.x + cat.w/2, cat.y + cat.h, 6, '#fce4b8');
            }
            // Soft down (crouch feel)
            if(keys['s'] || keys['arrowdown']) {
                if(!cat.onGround) cat.vy += 0.5;
            }

            // Physics
            cat.vx *= FRICTION;
            cat.vy += GRAVITY;
            cat.x += cat.vx;
            cat.y += cat.vy;

            // Clamp speed
            if(Math.abs(cat.vx) < 0.1) cat.vx = 0;

            if (cat.x < 0) { cat.x = 0; cat.vx = 0; }
            if (cat.x + cat.w > CANVAS_W) { cat.x = CANVAS_W - cat.w; cat.vx = 0; }

            // Ground collision
            cat.onGround = false;
            if(cat.y + cat.h >= GROUND_Y) {
                cat.y = GROUND_Y - cat.h;
                cat.vy = 0;
                cat.onGround = true;
            }

            // Platform collision
            platforms.forEach(plat => {
                const prevBottom = cat.y + cat.h - cat.vy;
                if(
                cat.x + cat.w > plat.x &&
                cat.x < plat.x + plat.w &&
                cat.y + cat.h >= plat.y &&
                cat.y + cat.h <= plat.y + plat.h + 4 &&
                cat.vy >= 0 &&
                prevBottom <= plat.y + 2
                ) {
                cat.y = plat.y - cat.h;
                cat.vy = 0;
                cat.onGround = true;
                if(!plat.touched) {
                    plat.touched = true;
                    score++;
                    scoreBar.textContent = `Boxes jumped on: ${score}`;
                    spawnParticles(cat.x + cat.w/2, cat.y + cat.h, 10, '#ffb7c5');
                    if(score === platforms.length) {
                    }
                }
                }
            });

            // State
            if(!cat.onGround) {
                cat.state = 'jump';
            } else if(Math.abs(cat.vx) > 0.5 || moving) {
                cat.state = 'run';
            } else {
                cat.state = 'idle';
            }

            cat.frame++;

            // Camera
            const targetCY = cat.y - CANVAS_H * 0.35;
            camera.y += (targetCY - camera.y) * 0.08;

            generatePlatformsUpTo(camera.y - CANVAS_H);
            //pruneOldPlatforms();

            updateParticles();
            }

            function draw() {
            ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

            // ── FIX: Background ──
            // Backg_no_grass.png is 1000×460 (matches canvas). Use natural dimensions
            // instead of hardcoded CANVAS_W/H so it doesn't stretch if image size changes.
            if (bgImage.complete && bgImage.naturalWidth > 0) {
                const bgW = bgImage.naturalWidth;   // ── FIX: was CANVAS_W ──
                const bgH = bgImage.naturalHeight;  // ── FIX: was CANVAS_H ──
                const parallaxY = -(camera.y * 0.2);
                const offsetY = ((parallaxY % bgH) + bgH) % bgH;
                ctx.drawImage(bgImage, 0, offsetY - bgH, bgW, bgH);
                ctx.drawImage(bgImage, 0, offsetY, bgW, bgH);
                ctx.drawImage(bgImage, 0, offsetY + bgH, bgW, bgH);
            } else {
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
            }

            // ── FIX: Ground ──
            // Grass.png is 1000×460 but the grass pixels only occupy the bottom 100px
            // (from source y:360 to y:460). The old code drew the ENTIRE 1000×460 image
            // squished into a 60px-tall strip, making it a blurry mess.
            // Now we use the 9-argument drawImage to CROP just the grass portion.
            const groundScreenY = GROUND_Y - camera.y;
            if (groundScreenY < CANVAS_H + 100) {
                if (groundImage.complete && groundImage.naturalWidth > 0) {
                    ctx.drawImage(groundImage,
                        0, 360, 1000, 100,              // ── FIX: source crop (just the grass) ──
                        0, groundScreenY, CANVAS_W, 300 // ── FIX: destination at natural height ──
                    );
                    // Was: ctx.drawImage(groundImage, x, groundScreenY, gw, 60)
                    // which stretched the full 460-tall image into 60px
                } else {
                    ctx.fillStyle = '#3a7a32';
                    ctx.fillRect(0, groundScreenY, CANVAS_W, 100);
                }
            }

            // ── FIX: Platforms ──
            // platform_1.png is 120×120 but the actual box content is 83×52 pixels,
            // located at (23,56) in the source image. The old code drew the full 120×120
            // image squished to plat.w × 24, making boxes look flat and distorted.
            // Now we scale the whole image proportionally so the visible box part
            // matches plat.w, and position it so the box top aligns with plat.y.
            platforms.forEach(plat => {
                const screenX = plat.x;
                const screenY = plat.y - camera.y;
                if (screenY > -80 && screenY < CANVAS_H) {
                    if (boxImage.complete && boxImage.naturalWidth > 0) {
                        // In the 120×120 source, the box content is:
                        //   starts at x:23, y:56  |  ends at x:106, y:108
                        //   content size: 83 wide, 52 tall
                        // We want the box content to be plat.w wide on screen.
                        const scale = plat.w / 83;           // how much to scale up from content
                        const fullDrawW = 120 * scale;       // scaled full image width
                        const fullDrawH = 120 * scale;       // scaled full image height (square)
                        const drawX = screenX - (23 * scale); // offset left for content alignment
                        const drawY = screenY - (56 * scale); // offset up for content alignment
                        ctx.drawImage(boxImage, drawX, drawY, fullDrawW, fullDrawH);
                    } else {
                        ctx.fillStyle = '#c49a6c';
                        ctx.fillRect(screenX, screenY, plat.w, plat.h);
                        ctx.strokeStyle = '#8b6914';
                        ctx.strokeRect(screenX, screenY, plat.w, plat.h);
                    }
                }
            });


            // Pick the right animation array based on cat.state
            let frames;
            if(cat.state === 'jump') frames = catJumpFrames;
            else if(cat.state === 'run') frames = catRunFrames;
            else frames = catIdleFrames;
            
            // Cycle through frames
            const frameIndex = Math.floor(cat.frame / TICKS_PER_FRAME) % frames.length;
            const img = frames[frameIndex];
            
            // ── FIX: Sprite position calculated from hitbox + offsets ──
            // The sprite is 64×64. The cat body within it starts at (HB_OFFSET_X, HB_OFFSET_Y).
            // cat.x/y is the hitbox top-left in world coords. To get sprite top-left:
            //   spriteX = cat.x - HB_OFFSET_X
            //   spriteY = cat.y - HB_OFFSET_Y
            const spriteScreenX = cat.x - HB_OFFSET_X;
            const spriteScreenY = (cat.y - HB_OFFSET_Y) - camera.y;
            
            //cat drawing
            ctx.save();
            if(cat.facing === -1) {
               ctx.translate(spriteScreenX + SPRITE_W, spriteScreenY);
               ctx.scale(-1, 1);
               ctx.drawImage(img, 0, 0, SPRITE_W, SPRITE_H);
            } else {
               ctx.drawImage(img, spriteScreenX, spriteScreenY, SPRITE_W, SPRITE_H);
            }
            ctx.restore();
  
            // ── Debug: red hitbox outline (comment out when satisfied) ──
            //ctx.strokeStyle = 'rgba(255,0,0,0.5)';
            //ctx.lineWidth = 1;
            //ctx.strokeRect(cat.x, cat.y - camera.y, cat.w, cat.h);

            globalFrame++;
            }
           
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
            
            gameLoop();
        </script>
    </body>

</html>
